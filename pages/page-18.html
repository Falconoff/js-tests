<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS-tests</title>
    <link rel="stylesheet" href="../css/styles-common.css" />
    <!-- <link rel="stylesheet" href="../css/styles-5.css" /> -->
  </head>
  <body>
    <h1>Объекты. Операции spread и rest</h1>

    <h2>Создание. Доступ к свойству объекта</h2>

    <p>
      Доступ к свойству объекта, для того чтобы получить или присвоить ему
      значение, может быть записан двумя способами:
    </p>

    <ul>
      <li><b>object.key</b> - через точку</li>
      <li>
        <b>object["key"]</b> - через квадратные скобки с именем ключа в кавычках
      </li>
    </ul>

    <p>
      Отсутствующее свойство, при обращении к нему по ключу, возвращает
      undefined.
    </p>

    <p>Короткие свойства (shorthand properties)</p>

    <p>Вычисляемые свойства</p>

    <p>
      Методы объекта. Объекты хранят не только данные, но и функции для работы с
      этими данными. Если значение свойства - это функция, то оно называется
      <b>методом объекта</b>.
    </p>
    <p>
      Для доступа к текущему объекту в методе используется не имя объекта, а
      ключевое слово <b>this</b> - контекст. Значением this является объект
      перед 'точкой', в контексте которого вызван метод.
    </p>

    <h2>Перебор объекта</h2>

    <ul>
      <li>Цикл for...in</li>
      <li>Object.keys(), Object.values(), Object.entries()</li>
    </ul>

    <h2>Операция spread</h2>
    <p>
      <b>...</b> - spread, распыление. Позволяет распылить коллекцию элементов в
      другую коллекцию, сделав копию оригинальной не изменяя ее. При этом, во
      время распыления, если элемент коллекции примитив - создается копия
      элемента, в случае сложного типа создается ссылка на оригинальный элемент.
    </p>
    <p>Распыление можно использовать всего в 3-х ситуациях:</p>
    <ul>
      <li>
        Во время вызова функции, для передачи массива элементов отдельными
        аргументами
      </li>
      <li>
        В литерале массива, при создании нового массива (копирование массива,
        замена методу <b>slice()</b> )
      </li>
      <li>
        В литерале объекта, при создании нового объекта (позволяет распылять
        свойства одного объекта в другой, замена методу <b>Object.assign()</b> )
      </li>
    </ul>

    <h2>Операция rest</h2>
    <p>
      <b>...</b> - rest, сбор. Позволяет скопировать группу элементов коллекции
      в новую коллекцию, не изменяя оригинальную. При этом, во время сбора, если
      элемент коллекции примитив - создается копия элемента, в случае сложного
      типа создается ссылка на оригинальный элемент.
    </p>
    <p>
      Используется в подписи функции для сбора аргументов или при
      деструктуризации, для хранения остатка элементов.
    </p>
    <div class="code">
      <i>const add = function (...args) { </i><br />
      <i class="tab">
        console.log(args);
        <span class="comment"> // массив всех аргументов </span> </i
      ><br />
      <i>};</i><br />
      <i>add(1, 2, 3); <span class="comment"> // [1, 2, 3] </span> </i><br />
    </div>

    <h2>Деструктуризация</h2>
    <h3>Деструктуризация объектов</h3>
    <p>
      Если имя переменной и ключ объекта совпадают, то происходит присваивание.
      Если для переменной не нашлось подходящего ключа, то будет присвоен
      undefined.
    </p>
    <div class="code"><i>const { name, stars, status } = hotel; </i><br /></div>
    <p>
      Присвоения undefined можно избежать, задав переменным значения по
      умолчанию, в случае если такого свойства в объекте нет.
    </p>
    <p>Mожно переопределить имена переменных в процессе присвоения.</p>
    <div class="code">
      <i
        >const { name: hotelName, stars, status: hotelStatus = 'empty' } =
        hotel; </i
      ><br />
    </div>

    <p>
      Используя операцию ... (rest) можно делать частичную деструктуризацию,
      взяв из объекта необходимые поля, а остальное собрать в переменную под
      именем rest (имя переменной произвольное), это будет объект с теми полями,
      которые мы явно не деструктуризировали в переменные.
    </p>
    <div class="code">
      <i>const { name, ...rest } = hotel;</i><br />
      <i>console.log(name); <span class="comment"> // "Resort Hotel" </span> </i
      ><br />
      <i
        >console.log(rest);
        <span class="comment"> // {stars: 5, capacity: 100} </span> </i
      ><br />
    </div>

    <h3>Деструктуризация массивов</h3>
    <p>
      Аналогично делается деструктуризация массивов. Переменным, указанным в [],
      будут последовательно присваиваться значения элементов массива
    </p>
    <div class="code">
      <i>const rgb = [200, 255, 100]; </i><br />
      <i>const [red, green, blue, alfa = 0.3] = rgb; </i><br />
    </div>

    <p>
      Иногда из массива необходимо деструктуризировать только первые n
      элементов, а остальные сохранить в одну переменную в виде массива. При
      деструкции массива можно распаковать и присвоить оставшуюся часть
      элементов массива переменной, используя операцию ... (rest).
    </p>
    <div class="code"><i>const [red, ...colors] = rgb;</i><br /></div>

    <p>Элементы можно пропускать. Используется это крайне редко.</p>
    <div class="code"><i>const [, , blue] = rgb;</i><br /></div>

    <!-- templates: -->

    <!-- <div class="code">
      <i>code <span class="comment"> // comments </span> </i><br />
      <i class="tab">code <span class="comment"> // comments </span> </i><br />
    </div> -->

    <!-- <ul>
      <li><b></b></li>
      <li>
        <b> </b>
      </li>
      <li><b></b></li>
      <li><b></b></li>
      <li><b></b></li>
      <li>
        <b></b>
      </li>
    </ul> -->

    <a href="../index.html" class="back-btn">back to main page</a>

    <script src="../js/script-18.js"></script>
  </body>
</html>
