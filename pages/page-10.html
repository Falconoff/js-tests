<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS-tests</title>
    <link rel="stylesheet" href="../css/styles-common.css" />
    <!-- <link rel="stylesheet" href="../css/styles-5.css" /> -->
  </head>
  <body>
    <h1>Строки</h1>

    <h2>кавычки</h2>

    <p>
      Одинарные и двойные кавычки работают, по сути, одинаково, а если
      использовать обратные кавычки, то в такую строку мы сможем вставлять
      произвольные выражения, обернув их в
      <b>${…}</b>.
    </p>
    <p>
      Ещё одно преимущество обратных кавычек — они могут занимать более одной
      строки
    </p>

    <h2>спецсимволы</h2>

    <ul>
      <li><b>\n</b> Перевод строки</li>
      <li>
        <b>\r </b>В текстовых файлах Windows для перевода строки используется
        комбинация символов \r\n, а на других ОС это просто \n. Это так по
        историческим причинам, ПО под Windows обычно понимает и просто \n.
      </li>
      <li><b>\', \"</b> Кавычки</li>
      <li><b>\\ </b>Обратный слеш</li>
      <li><b>\t</b> Знак табуляции</li>
      <li>
        <b>\b, \f, \v</b> Backspace, Form Feed и Vertical Tab — оставлены для
        обратной совместимости, сейчас не используются.
      </li>
    </ul>

    <p>
      все спецсимволы начинаются с обратного слеша, \ — так называемого «символа
      экранирования». Он также используется, если необходимо вставить в строку
      кавычку.
    </p>
    <p>
      <i>alert( 'I\'m the Walrus!' ); // I'm the Walrus!</i>
    </p>

    <h2>Доступ к символам</h2>
    <p>
      Получить символ, который занимает позицию pos, можно с помощью квадратных
      скобок: [pos]. Также можно использовать метод <b>str.at(pos)</b>. Первый
      символ занимает нулевую позицию
    </p>
    <p>
      преимущество метода .at(pos) заключается в том, что он допускает
      отрицательную позицию. Если pos – отрицательное число, то отсчет ведется
      от конца строки. Таким образом, .at(-1) означает последний символ, а
      .at(-2) – тот, что перед ним, и т.д. Квадратные скобки всегда возвращают
      undefined для отрицательных индексов.
    </p>

    <h2>Изменение регистра</h2>
    <p>
      Методы <b>toLowerCase()</b> и <b>toUpperCase()</b> меняют регистр
      символов.
    </p>

    <h2>Поиск подстроки</h2>

    <ul>
      <li>
        <h3>str.indexOf(substr, pos)</h3>
        <p>
          <b>str.indexOf(substr, pos)</b> - ищет подстроку substr в строке str,
          начиная с позиции pos, и возвращает позицию, на которой располагается
          совпадение, либо -1 при отсутствии совпадений.
        </p>
        <p>
          Также есть похожий метод
          <b>str.lastIndexOf(substr, position)</b>, который ищет с конца строки
          к её началу. Он используется тогда, когда нужно получить самое
          последнее вхождение: перед концом строки или начинающееся до
          (включительно) определённой позиции.
        </p>

        <h3>Трюк с побитовым НЕ</h3>
        <p>значение ~n равно -(n+1)</p>
        <p>if (~str.indexOf(…)) означает «если найдено».</p>
      </li>

      <li>
        <h3>includes, startsWith, endsWith</h3>
        <p>
          Более современный метод <b>str.includes(substr, pos)</b> возвращает
          true, если в строке str есть подстрока substr, либо false, если нет.
          Это — правильный выбор, если нам необходимо проверить, есть ли
          совпадение, но позиция не нужна
        </p>
        <p>
          Методы <b>str.startsWith</b> и <b>str.endsWith</b> проверяют,
          соответственно, начинается ли и заканчивается ли строка определённой
          строкой
        </p>
      </li>
      <li>
        <h3>Получение подстроки</h3>
        <p>
          В JavaScript есть 3 метода для получения подстроки: .
          <b>substring, substr и slice</b>
        </p>
        <ul>
          <li>
            <b>str.slice(start [, end])</b> Возвращает часть строки от start до
            (не включая) end. Если аргумент end отсутствует, slice возвращает
            символы до конца строки. Также для start/end можно задавать
            отрицательные значения. Это означает, что позиция определена как
            заданное количество символов с конца строки
          </li>
          <li>
            <b>str.substring(start [, end])</b> Возвращает часть строки между
            start и end (не включая) end. Это — почти то же, что и slice, но
            можно задавать start больше end. Если start больше end, то метод
            substring сработает так, как если бы аргументы были поменяны
            местами. Отрицательные значения substring, в отличие от slice, не
            поддерживает, они интерпретируются как 0.
          </li>
          <li>
            <b>str.substr(start [, length])</b> Возвращает часть строки от start
            длины length. В противоположность предыдущим методам, этот позволяет
            указать длину вместо конечной позиции
          </li>
        </ul>
      </li>
    </ul>

    <h2>Сравнение строк</h2>
    <p>
      строки сравниваются посимвольно в алфавитном порядке. Тем не менее, есть
      некоторые нюансы: Строчные буквы больше заглавных; Буквы, имеющие
      диакритические знаки, идут «не по порядку».
    </p>

    <p>
      <b>str.codePointAt(pos)</b> - Возвращает код для символа, находящегося на
      позиции pos
    </p>

    <a href="../index.html">back to main page</a>

    <script src="../js/script-10.js"></script>
  </body>
</html>
