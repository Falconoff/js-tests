<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JS-tests</title>
  <link rel="stylesheet" href="../css/styles-common.css" />
  <!-- <link rel="stylesheet" href="../css/styles-5.css" /> -->
</head>

<body>
  <h1>Массивы</h1>

  <h2></h2>

  <p><b>Массив (Array)</b> - упорядоченная коллекция данных.</p>

  <div class="code">
    <i>let arr = new Array();
      <span class="comment">
        // 1 вариант синтаксиса для создания пустого массива
      </span> </i><br />
    <i>let arr = [ ];
      <span class="comment">
        // 2 вариант синтаксиса для создания пустого массива
      </span> </i><br /><br />
    <i> let fruits = ["Яблоко", "Апельсин", "Слива"]; </i><br />
    <i>fruits[2] = 'Груша';
      <span class="comment">
        // теперь ["Яблоко", "Апельсин", "Груша"]
      </span> </i><br />
    <i>fruits[3] = 'Лимон';
      <span class="comment">// теперь ["Яблоко", "Апельсин", "Груша",
        "Лимон"]</span></i><br />
    <i>console.log( fruits.length ); <span class="comment">// 4</span></i>

    <p><i></i></p>
    <p><i></i></p>
    <p><i></i></p>
  </div>

  <h3>Получение последних элементов при помощи «at»</h3>

  <div class="code">
    <i>alert( fruits.at(1) ); <span class="comment"> // "Яблоко" </span>
    </i><br />
    <i>alert( fruits.at(-1) ); <span class="comment"> // "Лимон" </span>
    </i><br />
  </div>

  <h3>Методы, работающие с концом массива:</h3>
  <p><b>pop</b> - Удаляет последний элемент из массива; возвращает этот элемент
  </p>
  <p><b>push</b> - Добавляет элемент в конец массива; возвращает новую длину
    массива</p>

  <h3>Методы, работающие с началом массива:</h3>
  <p><b>shift</b> - Удаляет из массива первый элемент и возвращает его</p>
  <p><b>unshift</b> - Добавляет элемент в начало массива</p>
  <p>
    Методы <i>push</i> и <i>unshift</i> могут добавлять сразу несколько
    элементов
  </p>

  <h4>
    !!! Массив следует считать особой структурой, позволяющей работать с
    упорядоченными данными. Для этого массивы предоставляют специальные
    методы. Массивы тщательно настроены в движках JavaScript для работы с
    однотипными упорядоченными данными, поэтому, пожалуйста, используйте их
    именно в таких случаях. Если вам нужны произвольные ключи, вполне
    возможно, лучше подойдёт обычный объект {}.
  </h4>

  <p>Варианты неправильного применения массива:</p>
  <ul>
    <li>Добавление нечислового свойства, например: arr.test = 5.</li>
    <li>
      Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними
      ничего нет).
    </li>
    <li>
      Заполнение массива в обратном порядке, например: arr[1000], arr[999] и
      т.д.>
    </li>
  </ul>

  <p>
    <b>Методы push/pop выполняются быстро, а методы shift/unshift –
      медленно.</b>
  </p>

  <h2>Перебор элементов</h2>
  <p>
    Одним из самых старых способов перебора элементов массива является цикл
    for по цифровым индексам:
  </p>
  <div class="code">
    <i>for (let i = 0; i < arr.length; i++) {... </i><br />
  </div>

  <p>Но для массивов возможен и другой вариант цикла, for..of:</p>
  <div class="code"><i>for (let fruit of fruits) {... </i><br /></div>
  <p>
    Цикл for..of не предоставляет доступа к номеру текущего элемента, только к
    его значению, но в большинстве случаев этого достаточно. А также это
    короче.
  </p>
  <h4>!!! не следует использовать цикл <i>for..in</i> для массивов.</h4>

  <h3>Свойство length</h3>

  <p>
    Это не количество элементов массива, а наибольший цифровой индекс плюс
    один.
  </p>
  <p>
    Свойство length можно перезаписать. Если мы вручную увеличим его, ничего
    интересного не произойдёт. Зато, если мы уменьшим его, массив станет
    короче. Этот процесс необратим. Таким образом, самый простой способ
    очистить массив – это <i>arr.length = 0;</i>.
  </p>

  <h3>Многомерные массивы</h3>

  <div class="code">
    <i>let matrix = [ </i><br />
    <i> [1, 2, 3],</i><br />
    <i> [4, 5, 6],</i><br />
    <i> [7, 8, 9]</i><br />
    <i>]; </i><br />

    <i> </i><br />
    <i>alert( matrix[1][1] );
      <span class="comment"> // 5, центральный элемент </span> </i><br />
  </div>

  <h3>toString</h3>
  <p>
    метод <i>toString</i> возвращает список элементов, разделённых запятыми.
  </p>
  <div class="code">
    <i>let arr = [1, 2, 3]; </i><br />
    <i>console.log(String(arr)); <span class="comment"> // 1,2,3 </span>
    </i><br />
    <i>console.log(arr.toString() + 444);
      <span class="comment"> // 1,2,3444 </span> </i><br />
  </div>

  <p>
    Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они
    реализуют только преобразование toString, таким образом, здесь []
    становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".
  </p>
  <div class="code">
    <i>alert( [] + 1 ); <span class="comment"> // "1" </span> </i><br />
    <i>alert( [1] + 1 ); <span class="comment"> // "11" </span> </i><br />
    <i>alert( [1,2] + 1 ); <span class="comment"> // "1,21" </span> </i><br />
  </div>

  <h2>Не сравнивайте массивы при помощи ==</h2>
  <p>Давайте ещё раз напомним правила:</p>
  <ul>
    <li>
      Два объекта равны друг другу == только в том случае, если они ссылаются
      на один и тот же объект.
    </li>
    <li>
      Если один из аргументов == является объектом, а другой – примитивом, то
      объект преобразуется в примитив, как описано в главе Преобразование
      объектов в примитивы.
    </li>
    <li>
      …За исключением null и undefined, которые равны == друг другу и ничему
      больше.
    </li>
  </ul>
  <p>
    Оператор строгого равенства === ещё проще, так как он не преобразует типы.
  </p>
  <p>
    Итак, если мы всё же сравниваем массивы с помощью ==, то они никогда не
    будут одинаковыми, если только мы не сравним две переменные, которые
    ссылаются на один и тот же массив
  </p>
  <p>
    Сравнение с примитивами также может дать, казалось бы, странные
    результаты:
  </p>
  <div class="code">
    <i>alert(0 == [] ); <span class="comment"> // true </span> </i><br />
    <i>alert('0' == [] ); <span class="comment"> // false </span> </i><br />
  </div>
  <p>
    Здесь, в обоих случаях, мы сравниваем примитив с объектом массива. Таким
    образом, массив [] преобразуется в примитив с целью сравнения и становится
    пустой строкой ''. Затем продолжается процесс сравнения с примитивами, как
    описано в главе Преобразование типов.
  </p>
  <p>
    Так как же сравнить массивы? Это просто: не используйте оператор ==.
    Вместо этого
    <i>сравните их по элементам в цикле или используя методы итерации</i>,
    описанные в следующей главе.
  </p>

  <h3>Чтобы пройтись по элементам массива:</h3>
  <ul>
    <li>
      for (let i=0; i&lt;arr.length; i++) – работает быстрее всего, совместим
      со старыми браузерами.
    </li>
    <li>
      for (let item of arr) – современный синтаксис только для значений
      элементов (к индексам нет доступа).
    </li>
    <li>
      for (let i in arr) – никогда не используйте для массивов! Это для
      перебора объектов.
    </li>
  </ul>
  <!-- <div class="code">
      <i>code <span class="comment"> // comments </span> </i><br />
    </div> -->

  <!-- <ul>
      <li><b></b></li>
      <li>
        <b> </b>
      </li>
      <li><b></b></li>
      <li><b></b></li>
      <li><b></b></li>
      <li>
        <b></b>
      </li>
    </ul> -->

  <a href="../index.html" class="back-btn">back to main page</a>

  <script src="../js/script-11.js"></script>
</body>

</html>