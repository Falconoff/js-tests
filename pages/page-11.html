<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS-tests</title>
    <link rel="stylesheet" href="../css/styles-common.css" />
    <!-- <link rel="stylesheet" href="../css/styles-5.css" /> -->
  </head>
  <body>
    <h1>Массивы</h1>

    <h2>Методы массивов</h2>

    <h3>Добавление/удаление элементов</h3>

    <p>
      Мы уже знаем методы, которые добавляют и удаляют элементы из начала или
      конца:
    </p>

    <ul>
      <li>arr.push(...items) – добавляет элементы в конец,</li>
      <li>arr.pop() – извлекает элемент из конца,</li>
      <li>arr.shift() – извлекает элемент из начала,</li>
      <li>arr.unshift(...items) – добавляет элементы в начало.</li>
    </ul>

    <p>Есть и другие.</p>

    <p>
      Метод <b>arr.splice(str)</b> – это универсальный «швейцарский нож» для
      работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.
    </p>
    <p>
      <b>arr.splice(start[, deleteCount, elem1, ..., elemN]) </b>
      - изменяет <i>arr</i>, начиная с индекса <i>start</i>: удаляет
      <i>deleteCount</i> элементов и затем вставляет <i>elem1, ..., elemN</i> на
      их место. Возвращает массив из удалённых элементов.
      <br />
    </p>
    <p>
      В этом и в других методах массива допускается использование отрицательных
      индексов. Они определяют позицию с конца массива
    </p>

    <p>
      Метод <b>arr.slice()</b> намного проще, чем похожий на него arr.splice.
    </p>
    <p>
      <b>arr.slice([start], [end])</b>
      возвращает <i>новый массив, в который копирует</i> все элементы с индекса
      <i>start</i> до <i>end</i> (не включая <i>end</i>). <i>start</i> и
      <i>end</i> могут быть отрицательными, в этом случае отсчёт позиции будет
      вестись с конца массива.
    </p>
    <p>
      Это похоже на строковый метод str.slice, но вместо подстрок возвращает
      подмассивы.
    </p>
    <p>
      Можно вызвать <i>slice</i> без аргументов: <i>arr.slice()</i> создаёт
      копию <i>arr</i>. Это часто используют, чтобы создать копию массива для
      дальнейших преобразований, которые не должны менять исходный массив.
    </p>

    <p>
      Метод <b>arr.concat()</b> создаёт новый массив, в который копирует данные
      из других массивов и дополнительные значения.
    </p>
    <p>
      <b>arr.concat(arg1, arg2...)</b> – новый массив, включающий в себя
      элементы из <i>arr</i>, затем <i>arg1, arg2</i> и так далее. Если аргумент
      <i>argN</i> – массив, то копируются все его элементы. Иначе копируется сам
      аргумент.
    </p>

    <h3>forEach</h3>

    <p>
      Метод <b>arr.forEach</b>
      позволяет запускать функцию для каждого элемента массива.
    </p>
    <p>Синтаксис:</p>
    <div class="code">
      <i
        >arr.forEach(function(item, index, array) { // ... делать что-то с item
        }); <span class="comment"> </span> </i
      ><br />
    </div>

    <h2>Поиск в массиве</h2>

    <h3>indexOf, lastIndexOf и includes</h3>

    <p>
      <b>arr.indexOf(item, from)</b> ищет item начиная с индекса from и
      возвращает номер индекса, на котором был найден искомый элемент, в
      противном случае -1.
    </p>
    <p>Метод <b>arr.lastIndexOf</b> похож на indexOf, но ищет справа налево.</p>
    <p>
      <b>arr.includes(item, from)</b> ищет item начиная с индекса from и
      возвращает true, если поиск успешен.
    </p>

    <h3>find и findIndex/findLastIndex</h3>

    <p>
      Представьте, что у нас есть массив объектов. Как нам найти объект с
      определённым условием? Здесь пригодится метод <b>arr.find()</b>.
    </p>
    <div class="code">
      <i>let result = arr.find(function(item, index, array) { </i><br />
      <i>
        <span class="comment">
          // если true - возвращается текущий элемент item и перебор прерывается
        </span> </i
      ><br />
      <i>
        <span class="comment">
          // если все итерации оказались ложными, возвращается undefined
        </span> </i
      ><br />
      <i>}); </i><br />
    </div>
    <p>
      У метода <b>arr.findIndex</b> такой же синтаксис, но он возвращает индекс,
      на котором был найден элемент, а не сам элемент. Значение -1 возвращается,
      если ничего не найдено.
    </p>
    <p>
      <b>arr.findLastIndex</b> похож на findIndex, но ищет справа налево,
      наподобие lastIndexOf.
    </p>

    <h3>filter</h3>
    <p>
      Синтаксис схож с find, но <b>filter</b> возвращает массив из всех
      подходящих элементов:
    </p>

    <h2>Преобразование массива</h2>

    <h3>map()</h3>
    <p>
      Метод arr.map является одним из наиболее полезных и часто используемых. Он
      вызывает функцию для каждого элемента массива и возвращает массив
      результатов выполнения этой функции.
    </p>
    <div class="code">
      <i>let result = arr.map(function(item, index, array) { </i><br />
      <i>
        <span class="comment">
          // возвращается новое значение вместо элемента
        </span> </i
      ><br />
      <i>}); </i><br />
    </div>

    <h3>sort(fn)</h3>
    <p>
      Вызов<b> arr.sort()</b> сортирует массив <i>на месте</i>, меняя в нём
      порядок элементов.
    </p>

    <h3>Функция сравнения</h3>
    <p>
      от функции сравнения требуется любое положительное число, чтобы сказать
      «больше», и отрицательное число, чтобы сказать «меньше».
    </p>
    <div class="code">
      <i>let arr = [ 1, 2, 15 ]; </i><br />
      <i>arr.sort(function(a, b) { return a - b; }); </i><br />
      <i>alert(arr); <span class="comment"> // 1, 2, 15 </span> </i><br />
    </div>

    <p>Лучше использовать стрелочные функции</p>
    <div class="code">
      <i
        >arr.sort( (a, b) => a - b );
        <span class="comment">
          // Будет работать точно так же, как и более длинная версия выше
        </span> </i
      ><br />
    </div>

    <h3>reverse</h3>
    <p>
      <b>arr.reverse</b> меняет порядок элементов в arr на обратный, возвращает
      массив arr с изменённым порядком элементов.
    </p>

    <h3>split и join</h3>
    <p>
      Метод <b>str.split(delim)</b> разбивает строку на массив по заданному
      разделителю delim.
    </p>
    <p>
      У метода split есть необязательный второй числовой аргумент – ограничение
      на количество элементов в массиве. Если их больше, чем указано, то остаток
      массива будет отброшен. На практике это редко используется
    </p>
    <p>
      Вызов <i>str.split('')</i>с пустым аргументом разбил бы строку
      <i>str</i> на массив букв
    </p>

    <p>
      Вызов <b>arr.join(glue)</b> делает в точности противоположное split. Он
      создаёт строку из элементов arr, вставляя <i>glue</i> между ними.
    </p>

    <h3>reduce/reduceRight</h3>
    <p>
      Методы <b>arr.reduce</b> и <b>arr.reduceRight</b> похожи на методы выше,
      но они немного сложнее. Они используются для вычисления единого значения
      на основе всего массива.
    </p>
    <div class="code">
      <i>let value = arr.reduce(function(accumulator, item, index, array) { </i
      ><br />
      <i> <span class="comment"> // ... </span> </i><br />
      <i>}, [initial]);</i><br />
    </div>
    <p>
      Функция применяется по очереди ко всем элементам массива и «переносит»
      свой результат на следующий вызов. Аргументы:
    </p>
    <ul>
      <li>
        <b>accumulator</b> – результат предыдущего вызова этой функции, равен
        initial при первом вызове (если передан initial),
      </li>
      <li><b>item</b> – очередной элемент массива,</li>
      <li><b>index</b> – его позиция,</li>
      <li><b>array</b>– сам массив.</li>
    </ul>
    <!-- <div class="code">
      <i>code <span class="comment"> // comments </span> </i><br />
    </div> -->

    <!-- <ul>
      <li><b></b></li>
      <li>
        <b> </b>
      </li>
      <li><b></b></li>
      <li><b></b></li>
      <li><b></b></li>
      <li>
        <b></b>
      </li>
    </ul> -->

    <a href="../index.html" class="back-btn">back to main page</a>

    <script src="../js/script-12.js"></script>
  </body>
</html>
