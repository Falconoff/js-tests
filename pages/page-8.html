<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS-tests</title>
    <link rel="stylesheet" href="../css/styles-common.css" />
    <!-- <link rel="stylesheet" href="../css/styles-5.css" /> -->
  </head>
  <body>
    <h1>Объекты</h1>

    <h3>Клонирование и объединение, Object.assign</h3>

    <p>Object.assign(dest, [src1, src2, src3...])</p>
    <ul>
      <li>Первый аргумент dest — целевой объект.</li>
      <li>
        Остальные аргументы src1, ..., srcN (может быть столько, сколько
        необходимо) являются исходными объектами
      </li>
      <li>
        Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой
        объект dest. Другими словами, свойства всех аргументов, начиная со
        второго, копируются в первый объект.
      </li>
      <li>Возвращает объект dest.</li>
    </ul>
    <p>
      Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы
      не изобретать велосипед заново, возьмите готовую реализацию, например
      _.cloneDeep(obj) из библиотеки JavaScript lodash.
    </p>
    <p>
      Также мы можем использовать глобальный метод structuredClone(), который
      позволяет сделать полную копию объекта. К сожалению он поддерживается
      только современными браузерами. Здесь можно ознакомиться с поддержкой
      этого метода.
    </p>

    <h3>Функции-конструкторы</h3>

    <p>
      Чтобы создать множество похожих, однотипных объектов используются
      функции-конструкторы. Функции-конструкторы технически являются обычными
      функциями. Но есть два соглашения:
    </p>
    <ol>
      <li>Имя функции-конструктора должно начинаться с большой буквы.</li>
      <li>
        Функция-конструктор должна выполняться только с помощью оператора "new".
      </li>
    </ol>

    <h3>Опциональная цепочка '?.'</h3>
    <p>
      Опциональная цепочка ?. останавливает вычисление и возвращает undefined,
      если значение перед ?. равно undefined или null.
    </p>
    <div class="code">
      <pre>
        let user = {}; // пользователь без адреса
        alert( user?.address?.street ); // undefined (без ошибки)
    </pre
      >
    </div>
    <p>
      Нам следует использовать ?. только там, где нормально, что чего-то не
      существует. К примеру, если, в соответствии с логикой нашего кода, объект
      user должен существовать, но address является необязательным, то нам
      следует писать user.address?.street, но не user?.address?.street. В этом
      случае, если вдруг user окажется undefined, мы увидим программную ошибку
      по этому поводу и исправим её. В противном случае, если слишком часто
      использовать ?., ошибки могут замалчиваться там, где это неуместно, и их
      будет сложнее отлаживать.
    </p>

    <p>Синтаксис опциональной цепочки ?. имеет три формы:</p>
    <ol>
      <li>
        obj?.prop – возвращает obj.prop если obj существует, в противном случае
        undefined.
      </li>
      <li>
        obj?.[prop] – возвращает obj[prop] если obj существует, в противном
        случае undefined.
      </li>
      <li>
        obj.method?.() – вызывает obj.method(), если obj.method существует, в
        противном случае возвращает undefined.
      </li>
    </ol>

    <a href="../index.html">back to main page</a>

    <script src="../js/script-8.js"></script>
  </body>
</html>
